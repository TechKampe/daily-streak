<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover"/>
  <title>Memoria Pro: Electricidad Segura ⚡ | Kämpe</title>
  <meta name="theme-color" content="#1e4cf0"/>

  <!-- Manrope font -->
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link href="https://fonts.googleapis.com/css2?family=Manrope:wght@500;600;700;800&display=swap" rel="stylesheet">

  <style>
    /* Reset and base */
    *, *::before, *::after { box-sizing: border-box; }
    html, body { height: 100%; background: #0e1a5f; }
    html, body { overflow: hidden; overscroll-behavior: none; }
    body {
      margin: 0;
      font-family: "Manrope", system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji", "Segoe UI Emoji";
      color: #fff;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
      background: radial-gradient(1200px 800px at 80% -10%, #3ea0ff33, transparent) no-repeat,
                  radial-gradient(900px 600px at -10% 20%, #2667ff44, transparent) no-repeat,
                  linear-gradient(180deg, #0b1e87 0%, #07155a 60%, #051042 100%);
    }

    :root {
      --cols: 4;
      --rows: 2;
      --gap: 10px;
      --cardRadius: 14px;
      --cardGlass: rgba(255,255,255,0.08);
      --cardGlassStrong: rgba(255,255,255,0.16);
      --hudH: clamp(52px, 7svh, 64px);
      --titleSize: clamp(18px, 2.8vw, 22px);
      --chipSize: clamp(12px, 2.2vw, 14px);
      --cardFont: clamp(12px, 2.6vw, 16px);
      --cellAR: 0.72; /* height = width * AR */
      --ui-scale: 1;
      --shadow: 0 6px 24px rgba(0,0,0,0.28);
      --accent: #34f5c5;
      --accent2: #7cf2ff;
      --warn: #ffd966;
      --error: #ff6b6b;
      --success: #4dff88;
    }

    /* Scene sizing with safe height fallbacks */
    .scene {
      position: relative;
      width: 100%;
      height: 100vh;
      padding: calc(env(safe-area-inset-top, 0px) + 10px) 12px calc(env(safe-area-inset-bottom, 0px) + 12px);
      display: flex;
      flex-direction: column;
      align-items: stretch;
      justify-content: flex-start;
      transform-origin: top center;
      touch-action: none;
    }
    @supports (height: 100dvh) {
      .scene { height: 100dvh; }
    }
    @supports (height: 100svh) {
      .scene { height: 100svh; }
    }

    /* Inner wrapper to support autoscale without breaking safe-areas */
    .scene-inner {
      position: relative;
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
      transform-origin: top center;
    }

    /* Background avatar */
    .avatar-bg {
      position: absolute;
      inset: 0;
      background-position: right bottom;
      background-repeat: no-repeat;
      background-size: 60% auto;
      opacity: 0.18;
      pointer-events: none;
      filter: saturate(1.1) blur(0.2px);
      mix-blend-mode: screen;
    }

    /* HUD */
    .hud {
      min-height: var(--hudH);
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      padding: 8px 10px;
      background: linear-gradient(135deg, rgba(255,255,255,0.12), rgba(255,255,255,0.06));
      border: 1px solid rgba(255,255,255,0.15);
      border-radius: 16px;
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
    }
    .hud-left {
      display: flex;
      align-items: center;
      gap: 10px;
      min-width: 0;
    }
    .logo {
      width: 92px; height: 28px; object-fit: contain;
      filter: drop-shadow(0 2px 6px rgba(0,0,0,0.4));
    }
    .title {
      font-weight: 800;
      font-size: var(--titleSize);
      letter-spacing: 0.2px;
      margin: 0;
      text-shadow: 0 1px 0 rgba(0,0,0,0.5);
      display: -webkit-box;
      -webkit-line-clamp: 2;
      -webkit-box-orient: vertical;
      overflow: hidden;
      max-width: 56vw;
    }
    .hud-right {
      display: flex; align-items: center; gap: 8px;
      flex-shrink: 0;
    }
    .chip {
      background: linear-gradient(180deg, rgba(255,255,255,0.18), rgba(255,255,255,0.06));
      border: 1px solid rgba(255,255,255,0.22);
      padding: 8px 10px;
      border-radius: 999px;
      font-size: var(--chipSize);
      font-weight: 700;
      display: inline-flex; align-items: center; gap: 6px;
      white-space: nowrap;
    }
    .chip .dot {
      width: 9px; height: 9px; border-radius: 50%;
      background: var(--accent);
      box-shadow: 0 0 10px var(--accent);
    }
    .chip.warn .dot { background: var(--warn); box-shadow: 0 0 10px var(--warn); }
    .chip.danger .dot { background: var(--error); box-shadow: 0 0 10px var(--error); }

    /* Board container */
    .board-wrap {
      position: relative;
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      margin-top: 10px;
      margin-bottom: 8px;
      overflow: hidden; /* ensure no scroll in gameplay */
    }
    .board {
      width: 100%;
      max-width: 520px;
      display: grid;
      grid-template-columns: repeat(var(--cols), 1fr);
      grid-auto-rows: 1fr;
      gap: var(--gap);
      padding: 6px;
      touch-action: none;
    }

    /* Card */
    .card {
      position: relative;
      perspective: 1200px;
      border-radius: var(--cardRadius);
      user-select: none;
      -webkit-tap-highlight-color: transparent;
    }
    .card-inner {
      position: relative;
      width: 100%;
      /* compute height using AR: we base on width by using padding-top trick so it can shrink/grow with grid */
      aspect-ratio: calc(1 / var(--cellAR));
      border-radius: var(--cardRadius);
      transition: transform 380ms cubic-bezier(.2,.8,.2,1);
      transform-style: preserve-3d;
      box-shadow: 0 10px 24px rgba(0,0,0,0.32);
    }
    .card.flipped .card-inner {
      transform: rotateY(180deg) scale(1.03);
    }
    .card.matched .card-inner {
      transform: rotateY(180deg) scale(1.04);
      box-shadow: 0 12px 28px rgba(77,255,136,0.35), inset 0 0 0 2px rgba(77,255,136,0.8);
    }
    .face {
      position: absolute; inset: 0;
      border-radius: var(--cardRadius);
      backface-visibility: hidden; -webkit-backface-visibility: hidden;
      display: flex; align-items: center; justify-content: center;
      text-align: center;
      padding: 10px;
    }
    .front {
      background: linear-gradient(160deg, rgba(255,255,255,0.12), rgba(255,255,255,0.05));
      border: 1px solid rgba(255,255,255,0.22);
    }
    .back {
      transform: rotateY(180deg);
      background: linear-gradient(180deg, rgba(41,193,255,0.18), rgba(255,255,255,0.08));
      border: 1px solid rgba(255,255,255,0.30);
    }
    .card-label {
      display: -webkit-box;
      -webkit-line-clamp: 2;
      -webkit-box-orient: vertical;
      overflow: hidden;
      text-overflow: ellipsis;
      line-height: 1.15;
      font-weight: 800;
      font-size: var(--cardFont);
      letter-spacing: 0.1px;
      padding: 2px 4px;
      text-shadow: 0 1px 0 rgba(0,0,0,0.45);
    }
    .front .bolt {
      width: 34px; height: 34px;
      border-radius: 10px;
      background: radial-gradient(circle at 40% 30%, #fff, #fefa), linear-gradient(180deg, #fffb, #fff0);
      box-shadow: 0 0 16px #fff8;
      display: inline-flex; align-items: center; justify-content: center;
      color: #001845;
      font-weight: 900;
      font-size: 22px;
    }

    .card.matched .back {
      background: linear-gradient(200deg, rgba(77,255,136,0.25), rgba(255,255,255,0.08));
      border-color: rgba(77,255,136,0.9);
      box-shadow: inset 0 0 0 2px rgba(77,255,136,0.8);
    }
    .card.mismatch .card-inner { animation: shake 340ms; }
    @keyframes shake {
      0% { transform: rotateY(180deg) translateX(0); }
      25% { transform: rotateY(180deg) translateX(-3px); }
      50% { transform: rotateY(180deg) translateX(3px); }
      75% { transform: rotateY(180deg) translateX(-2px); }
      100% { transform: rotateY(180deg) translateX(0); }
    }

    /* Footer mini bar */
    .footer-bar {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      padding: 8px 10px;
    }
    .hint {
      font-size: 12px;
      opacity: 0.9;
      display: -webkit-box;
      -webkit-line-clamp: 2;
      -webkit-box-orient: vertical;
      overflow: hidden;
    }
    .button {
      appearance: none; border: 0;
      font-weight: 800; color: #001845;
      padding: 10px 14px;
      border-radius: 12px;
      min-height: 44px;
      background: linear-gradient(180deg, #51ffda, #2affff);
      box-shadow: 0 8px 18px rgba(41,193,255,0.35), inset 0 -2px 0 rgba(0,0,0,0.15);
      cursor: pointer;
    }
    .button:focus-visible {
      outline: 3px solid #fff;
      outline-offset: 2px;
    }
    .button.secondary {
      background: linear-gradient(180deg, rgba(255,255,255,0.22), rgba(255,255,255,0.1));
      color: #fff;
      border: 1px solid rgba(255,255,255,0.25);
      box-shadow: none;
    }

    /* Modals */
    .modal {
      position: fixed;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      padding: 16px;
      z-index: 30;
      pointer-events: none;
    }
    .modal.active { display: flex; pointer-events: auto; }
    .modal .panel {
      width: min(680px, 100%);
      max-height: 90svh;
      background: linear-gradient(160deg, rgba(255,255,255,0.16), rgba(255,255,255,0.08));
      border: 1px solid rgba(255,255,255,0.28);
      border-radius: 18px;
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      padding: 16px;
      overflow-y: auto;
    }
    .panel h2 {
      margin: 6px 0 8px 0;
      font-size: clamp(20px, 3.4vw, 26px);
      line-height: 1.15;
      letter-spacing: 0.2px;
      font-weight: 800;
    }
    .panel p {
      margin: 8px 0;
      font-size: clamp(14px, 2.5vw, 16px);
      opacity: 0.96;
      line-height: 1.25;
    }
    .panel .cta-row {
      display: flex; gap: 10px; align-items: center; justify-content: stretch;
      margin-top: 10px;
      position: sticky; bottom: 0;
      background: linear-gradient(180deg, transparent, rgba(5,16,66,0.55) 22%, rgba(5,16,66,0.85) 100%);
      padding-top: 10px; padding-bottom: calc(env(safe-area-inset-bottom, 0px) + 6px);
    }
    .panel .cta-row .button { flex: 1; }

    /* Results list */
    .pairs-list {
      display: grid;
      grid-template-columns: 1fr;
      gap: 8px;
      margin: 10px 0;
    }
    .pair-item {
      background: linear-gradient(180deg, rgba(255,255,255,0.14), rgba(255,255,255,0.06));
      border: 1px solid rgba(255,255,255,0.25);
      border-radius: 12px;
      padding: 10px;
      display: grid; gap: 6px;
      box-shadow: 0 6px 14px rgba(0,0,0,0.2);
    }
    .pair-tags {
      display: flex; gap: 6px; flex-wrap: wrap;
    }
    .tag {
      background: rgba(0,0,0,0.25);
      border: 1px solid rgba(255,255,255,0.24);
      padding: 4px 8px;
      border-radius: 999px;
      font-size: 12px;
      font-weight: 800;
    }
    .tag.ok { background: rgba(77,255,136,0.22); border-color: rgba(77,255,136,0.65); color: #d9ffe8; }
    .tag.miss { background: rgba(255,107,107,0.22); border-color: rgba(255,107,107,0.65); color: #ffe1e1; }

    /* Accessibility helper */
    .sr-only {
      position: absolute !important; width: 1px !important; height: 1px !important;
      padding: 0 !important; margin: -1px !important; overflow: hidden !important;
      clip: rect(0,0,0,0) !important; white-space: nowrap !important; border: 0 !important;
    }

    /* Compact mode when needed */
    .compact .hud { min-height: calc(var(--hudH) - 10px); padding: 6px 8px; }
    .compact .title { font-size: clamp(16px, 2.3vw, 18px); max-width: 50vw; }
    .compact .chip { padding: 6px 8px; font-size: 12px; }
    .compact .board { gap: 8px; }
    .compact .card-label { font-size: clamp(11px, 2.2vw, 14px); }
    .compact .footer-bar .hint { font-size: 11px; }
    .compact .button { padding: 9px 12px; }

    /* Focus visible */
    .card:focus-visible .front,
    .card:focus-visible .back {
      outline: 3px solid #fff;
      outline-offset: 2px;
    }

    /* Always keep CTAs visible in gameplay (none other than flips), intro and results use sticky CTA rows already */

    /* Prevent text selection and image dragging */
    img { user-drag: none; -webkit-user-drag: none; }
  </style>
</head>
<body>
  <div class="scene">
    <div class="scene-inner" id="sceneInner" style="transform: scale(1);">
      <div class="avatar-bg" id="avatarBg" style="background-image: url('https://techkampe.github.io/daily-streak/assets/Avatar%203_low.png');"></div>

      <header class="hud" aria-label="Barra superior">
        <div class="hud-left">
          <img class="logo" src="https://techkampe.github.io/daily-streak/assets/kampe_logo_blanco.png" alt="Kämpe" />
          <h1 class="title">Memoria Pro: Electricidad Segura ⚡</h1>
        </div>
        <div class="hud-right">
          <div class="chip" id="attemptsChip" aria-live="polite">
            <span class="dot"></span>
            <span>Intentos: <strong id="attemptsText">0/12</strong></span>
          </div>
        </div>
      </header>

      <main class="board-wrap" aria-label="Tablero de cartas">
        <div class="board" id="board" role="grid" aria-label="Memorama 8 cartas">
          <!-- Cards placeholder -->
        </div>
      </main>

      <div class="footer-bar">
        <div class="hint">Gira dos cartas por turno. Coincidencias se fijan; fallos se tapan en 1 s.</div>
        <button class="button secondary" id="restartBtn" aria-label="Reiniciar partida" title="Reiniciar">
          Reiniciar
        </button>
      </div>
    </div>
  </div>

  <!-- Intro Modal -->
  <div class="modal active" id="introModal" aria-modal="true" role="dialog" aria-labelledby="introTitle">
    <div class="panel">
      <h2 id="introTitle">Memoria Pro: Electricidad Segura ⚡</h2>
      <p>Escenario: vas a intervenir un circuito doméstico. Empareja herramienta/procedimiento con su función para actuar con seguridad.</p>
      <p>Tutorial: toca dos cartas; si coinciden, se quedan. Tienes 12 intentos para hallar 4 parejas.</p>
      <div class="cta-row">
        <button class="button" id="startBtn" aria-label="Comenzar">Comenzar</button>
      </div>
    </div>
  </div>

  <!-- Results Modal -->
  <div class="modal" id="resultsModal" aria-modal="true" role="dialog" aria-labelledby="resultsTitle">
    <div class="panel">
      <h2 id="resultsTitle">Resultados</h2>
      <p id="summaryText">Resumen de tu sesión.</p>

      <div class="pairs-list" id="pairsList">
        <!-- Filled dynamically: each pair and explanation -->
      </div>

      <p><strong>Consejo de estudio:</strong> aplica la regla “comprobar–aislar–proteger”. Primero verifica ausencia de tensión, luego bloquea y etiqueta, y por último usa EPI.</p>

      <div class="cta-row">
        <div id="initDataWarn" style="display:none; color:#ffd966; font-size:12px; font-weight:700; margin-right:8px;">initData no detectado</div>
        <button class="button" id="rewardBtn" aria-label="Ver mi recompensa">Ver mi recompensa</button>
      </div>
    </div>
  </div>

  <div class="sr-only" aria-live="polite" id="liveRegion"></div>

  <script>
    /* ------------------------
       Data and constants
    -------------------------*/
    const MAX_ATTEMPTS = 12;
    const TOTAL_PAIRS = 4;
    const CARD_TEXT_MAX = 48; // labels max length
    const MODAL_TEXT_MAX = 180; // messages max char (guideline; intro kept short)
    const PAIRS_DATA = [
      {
        key: "multimetro",
        term: "Multímetro",
        meaning: "Medir tensión",
        explain: "El multímetro permite medir tensión y verificar valores antes de intervenir."
      },
      {
        key: "guantes",
        term: "Guantes dieléctricos",
        meaning: "Proteger de descargas",
        explain: "Guantes aislantes homologados evitan el paso de corriente por tu cuerpo."
      },
      {
        key: "loto",
        term: "Bloqueo-etiquetado (LOTO)",
        meaning: "Cortar y señalizar",
        explain: "Bloquea y etiqueta para impedir reconexiones accidentales durante el trabajo."
      },
      {
        key: "detector",
        term: "Detector de tensión",
        meaning: "Verificar circuito sin energía",
        explain: "Comprueba rápidamente si existe tensión en el punto de trabajo."
      }
    ];

    /* ------------------------
       State
    -------------------------*/
    const state = {
      initData: "",
      deck: [],
      flipped: [],
      matchedKeys: new Set(),
      attempts: 0,
      lock: false,
      finished: false,
      compactApplied: false,
      fitStep: 0
    };

    /* ------------------------
       Helpers
    -------------------------*/
    function getInitData() {
      try {
        const params = new URLSearchParams(location.search);
        return params.get('initData') || "";
      } catch (e) {
        return "";
      }
    }

    function clampLabel(text, max = CARD_TEXT_MAX) {
      text = String(text || "");
      if (text.length <= max) return text;
      return text.slice(0, max - 1) + "…";
    }

    function shuffle(array) {
      for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
      }
      return array;
    }

    function announce(msg) {
      const live = document.getElementById('liveRegion');
      live.textContent = "";
      setTimeout(()=> {
        live.textContent = msg;
      }, 40);
    }

    function setChipDangerLevel() {
      const chip = document.getElementById('attemptsChip');
      chip.classList.remove('warn', 'danger');
      if (state.attempts >= MAX_ATTEMPTS - 2 && !state.finished) chip.classList.add('danger');
      else if (state.attempts >= Math.ceil(MAX_ATTEMPTS * 0.7) && !state.finished) chip.classList.add('warn');
    }

    /* ------------------------
       Build deck and render
    -------------------------*/
    function buildDeck() {
      const deck = [];
      PAIRS_DATA.forEach(p => {
        deck.push({ id: p.key + "_t", key: p.key, text: clampLabel(p.term), role: "term" });
        deck.push({ id: p.key + "_m", key: p.key, text: clampLabel(p.meaning), role: "meaning" });
      });
      return shuffle(deck);
    }

    function createCardEl(card, index) {
      const el = document.createElement('div');
      el.className = 'card';
      el.setAttribute('role', 'button');
      el.setAttribute('tabindex', '0');
      el.setAttribute('aria-label', `Carta ${index + 1}. Toca para revelar.`);
      el.dataset.id = card.id;
      el.dataset.key = card.key;
      el.dataset.role = card.role;

      const inner = document.createElement('div');
      inner.className = 'card-inner';

      const front = document.createElement('div');
      front.className = 'face front';
      const bolt = document.createElement('div');
      bolt.className = 'bolt';
      bolt.textContent = "⚡";
      front.appendChild(bolt);

      const back = document.createElement('div');
      back.className = 'face back';
      const label = document.createElement('div');
      label.className = 'card-label';
      label.textContent = card.text;
      label.title = card.text;
      back.appendChild(label);

      inner.appendChild(front);
      inner.appendChild(back);
      el.appendChild(inner);

      // Events
      el.addEventListener('click', () => onCardClicked(el));
      el.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' || e.key === ' ') {
          e.preventDefault();
          onCardClicked(el);
        }
      });

      return el;
    }

    function renderBoard() {
      const board = document.getElementById('board');
      board.innerHTML = '';
      state.deck.forEach((card, index) => {
        const el = createCardEl(card, index);
        board.appendChild(el);
      });
    }

    /* ------------------------
       Game logic
    -------------------------*/
    function onCardClicked(el) {
      if (state.lock || state.finished) return;
      if (el.classList.contains('matched')) return;
      if (state.flipped.includes(el)) return;

      flipCard(el);

      state.flipped.push(el);
      if (state.flipped.length === 2) {
        state.lock = true;
        // New attempt (turn) used
        state.attempts++;
        updateAttempts();
        setChipDangerLevel();

        const [a, b] = state.flipped;
        if (a.dataset.key === b.dataset.key) {
          // Match
          setTimeout(() => {
            a.classList.add('matched');
            b.classList.add('matched');
            state.matchedKeys.add(a.dataset.key);
            clearFlipped();
            state.lock = false;
            announce('¡Pareja correcta!');
            checkEnd();
          }, 250);
        } else {
          // Mismatch
          setTimeout(() => {
            a.classList.add('mismatch');
            b.classList.add('mismatch');
          }, 50);
          setTimeout(() => {
            unflipCard(a);
            unflipCard(b);
            a.classList.remove('mismatch');
            b.classList.remove('mismatch');
            clearFlipped();
            state.lock = false;
            announce('No coinciden.');
            checkEnd();
          }, 1000);
        }
      }
    }

    function flipCard(el) {
      el.classList.add('flipped');
      el.setAttribute('aria-pressed', 'true');
    }
    function unflipCard(el) {
      el.classList.remove('flipped');
      el.removeAttribute('aria-pressed');
    }
    function clearFlipped() {
      state.flipped.length = 0;
    }

    function updateAttempts() {
      const t = document.getElementById('attemptsText');
      t.textContent = `${state.attempts}/${MAX_ATTEMPTS}`;
    }

    function checkEnd() {
      const allMatched = state.matchedKeys.size >= TOTAL_PAIRS;
      const outOfAttempts = state.attempts >= MAX_ATTEMPTS && !allMatched;
      if (allMatched || outOfAttempts) {
        state.finished = true;
        setTimeout(showResults, 350);
      }
    }

    function restart() {
      state.deck = buildDeck();
      state.flipped = [];
      state.matchedKeys = new Set();
      state.attempts = 0;
      state.lock = false;
      state.finished = false;
      updateAttempts();
      setChipDangerLevel();
      renderBoard();
      ensureFits();
      announce('Partida reiniciada.');
    }

    /* ------------------------
       Results
    -------------------------*/
    function showResults() {
      // prepare summary
      const attempts = state.attempts;
      const matches = state.matchedKeys.size;
      const summary = document.getElementById('summaryText');
      if (matches >= TOTAL_PAIRS) {
        summary.textContent = `¡Perfecto! Aciertos: ${matches}/${TOTAL_PAIRS}. Intentos usados: ${attempts}/${MAX_ATTEMPTS}.`;
      } else {
        summary.textContent = `Fin de intentos. Aciertos: ${matches}/${TOTAL_PAIRS}. Intentos usados: ${attempts}/${MAX_ATTEMPTS}.`;
      }

      const list = document.getElementById('pairsList');
      list.innerHTML = '';
      PAIRS_DATA.forEach(p => {
        const item = document.createElement('div');
        item.className = 'pair-item';
        const tags = document.createElement('div');
        const matched = state.matchedKeys.has(p.key);
        tags.className = 'pair-tags';
        const t1 = document.createElement('span'); t1.className = 'tag' + (matched ? ' ok':' miss'); t1.textContent = p.term;
        const t2 = document.createElement('span'); t2.className = 'tag' + (matched ? ' ok':' miss'); t2.textContent = p.meaning;
        tags.appendChild(t1); tags.appendChild(t2);

        const explain = document.createElement('p');
        explain.style.margin = "0";
        let text = p.explain;
        if (text.length > MODAL_TEXT_MAX) text = text.slice(0, MODAL_TEXT_MAX - 1) + '…';
        explain.textContent = text;

        item.appendChild(tags);
        item.appendChild(explain);
        list.appendChild(item);
      });

      // Show modal
      const modal = document.getElementById('resultsModal');
      modal.classList.add('active');
      // allow scroll ONLY inside results panel (panel already has overflow-y auto)
      document.querySelectorAll('.modal .panel').forEach(p => p.style.overflowY = 'auto');
      // warn if no initData
      const warn = document.getElementById('initDataWarn');
      if (!state.initData) warn.style.display = 'block';
      else warn.style.display = 'none';
    }

    /* ------------------------
       ensureFits system
       1) assertNoOverflow -> OK
       2) applyCompactMode
       3) fitBoardToViewport (reduce AR, gap)
       4) autoscaleUI (scale down to min 0.88)
    -------------------------*/
    function assertNoOverflow() {
      const scene = document.querySelector('.scene');
      return scene.scrollHeight <= scene.clientHeight;
    }

    function applyCompactMode() {
      if (!state.compactApplied) {
        document.body.classList.add('compact');
        state.compactApplied = true;
      }
    }

    function resetCompactMode() {
      document.body.classList.remove('compact');
      state.compactApplied = false;
    }

    function fitBoardToViewport() {
      // progressively reduce aspect ratio and gap to lower height usage
      const root = document.documentElement;
      state.fitStep++;
      if (state.fitStep === 1) {
        root.style.setProperty('--cellAR', '0.68');
        root.style.setProperty('--gap', '8px');
      } else if (state.fitStep === 2) {
        root.style.setProperty('--cellAR', '0.62');
        root.style.setProperty('--gap', '6px');
      } else if (state.fitStep >= 3) {
        root.style.setProperty('--cellAR', '0.58');
        root.style.setProperty('--gap', '5px');
      }
    }

    function autoscaleUI() {
      const wrapper = document.getElementById('sceneInner');
      let scale = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--ui-scale')) || 1;
      // decrease in small steps until fit or min
      let tries = 0;
      while (!assertNoOverflow() && scale > 0.88 && tries < 6) {
        scale -= 0.03;
        tries++;
        wrapper.style.transform = `scale(${scale})`;
      }
      document.documentElement.style.setProperty('--ui-scale', String(scale));
    }

    function ensureFits() {
      const wrapper = document.getElementById('sceneInner');
      // Reset
      resetCompactMode();
      document.documentElement.style.setProperty('--cellAR', '0.72');
      document.documentElement.style.setProperty('--gap', '10px');
      document.documentElement.style.setProperty('--ui-scale', '1');
      state.fitStep = 0;
      wrapper.style.transform = 'scale(1)';

      // Step 1: check
      if (assertNoOverflow()) return;
      // Step 2: compact mode
      applyCompactMode();
      if (assertNoOverflow()) return;
      // Step 3: try fitBoard multiple steps
      fitBoardToViewport();
      if (assertNoOverflow()) return;
      fitBoardToViewport();
      if (assertNoOverflow()) return;
      // Step 4: autoscale
      autoscaleUI();
    }

    /* ------------------------
       Event bindings
    -------------------------*/
    function bindUI() {
      const startBtn = document.getElementById('startBtn');
      const intro = document.getElementById('introModal');
      startBtn.addEventListener('click', () => {
        intro.classList.remove('active');
        ensureFits();
      });

      const rewardBtn = document.getElementById('rewardBtn');
      rewardBtn.addEventListener('click', () => {
        const base = 'https://kampe-game-phaser.onrender.com/daily_streak';
        const url = base + '?initData=' + encodeURIComponent(state.initData || "");
        window.location.href = url;
      });

      const restartBtn = document.getElementById('restartBtn');
      restartBtn.addEventListener('click', () => {
        // If results open, close it and restart
        const results = document.getElementById('resultsModal');
        results.classList.remove('active');
        restart();
      });

      window.addEventListener('resize', () => ensureFits());
      window.addEventListener('orientationchange', () => {
        setTimeout(ensureFits, 250);
      });
      // Prevent pull-to-refresh on board
      const board = document.getElementById('board');
      board.addEventListener('touchmove', (e) => { e.preventDefault(); }, { passive: false });
    }

    /* ------------------------
       Init
    -------------------------*/
    function init() {
      state.initData = getInitData();
      state.deck = buildDeck();
      renderBoard();
      updateAttempts();
      setChipDangerLevel();
      bindUI();
      // Initial fit pass (with intro visible, but we'll call again when intro closes)
      ensureFits();
    }

    // Kick off
    document.addEventListener('DOMContentLoaded', init);
  </script>
</body>
</html>