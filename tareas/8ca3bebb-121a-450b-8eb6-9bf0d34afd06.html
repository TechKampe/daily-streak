<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Kämpe | Corta la Corriente ⚡</title>
  <meta name="color-scheme" content="light dark" />
  <link rel="preconnect" href="https://fonts.googleapis.com" crossorigin>
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Manrope:wght@500;600;700;800&display=swap" rel="stylesheet">
  <style>
    /* Reset and base */
    *, *::before, *::after { box-sizing: border-box; }
    html, body { height: 100%; }
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;              /* Block global scroll during gameplay */
      overscroll-behavior: none;     /* Anti-derrapes */
      background: #0d59ff; /* fallback */
      font-family: Manrope, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      color: #f7f9ff;
    }
    :root {
      --bg1: #0950f5;
      --bg2: #1279ff;
      --accent: #00f7ff;
      --accent-2: #66ff7b;
      --danger: #ff4d6d;
      --warning: #ffd166;
      --glass: rgba(255,255,255,0.14);
      --glass-2: rgba(255,255,255,0.18);
      --stroke: rgba(255,255,255,0.2);
      --shadow: 0 10px 30px rgba(0,0,0,0.28);
      --ui-scale: 1;
      --gap: 12px;
      --btnH: 56px; /* ensure >=44px */
      --radius: 16px;
      --title-size: clamp(18px, 4.5vw, 24px);
      --question-size: clamp(18px, 5vw, 22px);
      --option-size: clamp(14px, 4.2vw, 16px);
      --chip-size: clamp(12px, 3.5vw, 14px);
    }

    /* Scene sizing with svh/dvh/vh fallback */
    .scene {
      position: relative;
      width: 100%;
      height: 100vh; /* fallback of fallback */
      display: flex;
      align-items: stretch;
      justify-content: center;
      isolation: isolate;
      background: radial-gradient(120% 100% at 50% 0%, var(--bg2), var(--bg1) 70%);
      touch-action: none; /* Anti-derrapes in gameplay */
      padding:
        calc(10px + env(safe-area-inset-top))
        calc(12px + env(safe-area-inset-right))
        calc(12px + env(safe-area-inset-bottom))
        calc(12px + env(safe-area-inset-left));
      overflow: hidden;
    }
    @supports (height: 100dvh) {
      .scene { height: 100dvh; }
    }
    @supports (height: 100svh) {
      .scene { height: 100svh; }
    }

    /* Background avatar + shine */
    .avatar-bg {
      position: absolute;
      inset: 0;
      width: 120%;
      height: 120%;
      object-fit: cover;
      object-position: center;
      opacity: 0.25;
      filter: saturate(1.1) contrast(1.05) blur(0.2px);
      transform: translateY(-5%) scale(1.05);
      pointer-events: none;
      z-index: 0;
    }
    .bg-noise {
      position: absolute;
      inset: 0;
      background-image: radial-gradient(transparent 70%, rgba(255,255,255,0.06)),
                        url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" opacity="0.10" viewBox="0 0 100 100"><filter id="n"><feTurbulence type="fractalNoise" baseFrequency="1.2" numOctaves="2" stitchTiles="stitch"/></filter><rect width="100%" height="100%" filter="url(%23n)"/></svg>');
      background-size: cover, 300px 300px;
      mix-blend-mode: soft-light;
      pointer-events: none;
      z-index: 0;
    }

    /* App wrapper that we may scale */
    .app {
      position: relative;
      z-index: 2;
      width: 100%;
      max-width: 520px;
      margin: 0 auto;
      transform-origin: top center;
      transform: scale(var(--ui-scale));
      display: flex;
      flex-direction: column;
      gap: var(--gap);
    }

    /* HUD */
    .hud {
      display: flex;
      align-items: center;
      justify-content: space-between;
      backdrop-filter: blur(10px);
      background: linear-gradient(180deg, var(--glass), rgba(255,255,255,0.08));
      border: 1px solid var(--stroke);
      border-radius: var(--radius);
      padding: 8px 10px;
      box-shadow: var(--shadow);
      min-height: 56px;
    }
    .hud-left {
      display: flex;
      align-items: center;
      gap: 10px;
      min-width: 0;
    }
    .logo {
      width: 100px;
      height: auto;
      display: block;
      user-select: none;
      pointer-events: none;
    }
    .title {
      font-weight: 800;
      font-size: var(--title-size);
      line-height: 1.1;
      letter-spacing: 0.2px;
      text-shadow: 0 2px 10px rgba(0,0,0,0.4);
      max-width: 64vw;
      display: -webkit-box;
      -webkit-line-clamp: 2;
      line-clamp: 2;
      -webkit-box-orient: vertical;
      overflow: hidden;
    }
    .progress-chip {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      font-weight: 700;
      font-size: var(--chip-size);
      padding: 8px 12px;
      color: #001232;
      background: linear-gradient(180deg, #7af0ff, #5be1ff);
      border-radius: 999px;
      border: 1px solid rgba(0, 0, 0, 0.08);
      box-shadow: 0 4px 14px rgba(0,0,0,0.18), inset 0 1px 0 rgba(255,255,255,0.55);
      min-width: 62px;
      justify-content: center;
    }

    /* Card (question + options) */
    .card {
      display: flex;
      flex-direction: column;
      gap: calc(var(--gap) + 2px);
      backdrop-filter: blur(14px);
      background: linear-gradient(180deg, var(--glass-2), rgba(255,255,255,0.08));
      border: 1px solid var(--stroke);
      border-radius: calc(var(--radius) + 2px);
      padding: 14px;
      box-shadow: var(--shadow);
      min-height: 0;
    }
    .question {
      font-size: var(--question-size);
      font-weight: 800;
      line-height: 1.15;
      letter-spacing: 0.2px;
      display: -webkit-box;
      -webkit-line-clamp: 2;
      line-clamp: 2;
      -webkit-box-orient: vertical;
      overflow: hidden;
      min-height: 48px;
    }
    .options {
      display: grid;
      grid-template-columns: 1fr;
      gap: var(--gap);
    }
    .option-btn {
      position: relative;
      border: 1px solid rgba(255,255,255,0.25);
      border-radius: 14px;
      min-height: var(--btnH); /* >=44px */
      padding: 12px 14px;
      text-align: left;
      color: #f7fbff;
      background: linear-gradient(180deg, rgba(255,255,255,0.10), rgba(255,255,255,0.05));
      backdrop-filter: blur(8px);
      font-size: var(--option-size);
      font-weight: 700;
      cursor: pointer;
      box-shadow: 0 8px 18px rgba(0,0,0,0.22), inset 0 1px 0 rgba(255,255,255,0.15);
      transition: transform 140ms ease, background 140ms ease, border-color 140ms ease, box-shadow 140ms ease;
      user-select: none;
      outline: none;
    }
    .option-btn .label {
      display: -webkit-box;
      -webkit-line-clamp: 2;
      line-clamp: 2;
      -webkit-box-orient: vertical;
      overflow: hidden;
    }
    .option-btn:hover, .option-btn:active {
      transform: translateY(-1px);
      background: linear-gradient(180deg, rgba(255,255,255,0.16), rgba(255,255,255,0.08));
    }
    .option-btn:focus-visible {
      outline: 3px solid #00f7ff;
      outline-offset: 2px;
    }
    .option-btn.correct {
      border-color: rgba(102,255,123,0.95);
      box-shadow: 0 8px 22px rgba(0, 255, 128, 0.2), inset 0 1px 0 rgba(255,255,255,0.2);
    }
    .option-btn.wrong {
      border-color: rgba(255,77,109,0.95);
      box-shadow: 0 8px 22px rgba(255, 77, 109, 0.25), inset 0 1px 0 rgba(255,255,255,0.2);
    }

    /* Slide animations */
    .slide-in-right { animation: slideIn 260ms cubic-bezier(.2,.8,.2,1); }
    .slide-out-left { animation: slideOut 240ms cubic-bezier(.2,.8,.2,1); }
    @keyframes slideIn {
      from { opacity: 0; transform: translateX(24px); }
      to   { opacity: 1; transform: translateX(0); }
    }
    @keyframes slideOut {
      from { opacity: 1; transform: translateX(0); }
      to   { opacity: 0; transform: translateX(-24px); }
    }
    @media (prefers-reduced-motion: reduce) {
      .slide-in-right, .slide-out-left { animation-duration: 1ms; }
      .option-btn { transition: none; }
    }

    /* Intro modal */
    .modal {
      position: absolute;
      inset: 0;
      display: grid;
      place-items: center;
      padding: 16px;
      background: linear-gradient(180deg, rgba(2,7,40,0.45), rgba(2,7,40,0.55));
      z-index: 5;
    }
    .modal-card {
      width: min(640px, 94vw);
      max-height: 90svh;
      @supports not (height: 100svh) { max-height: 90dvh; }
      @supports not (height: 100dvh) { max-height: 90vh; }
      overflow-y: auto;
      background: linear-gradient(180deg, rgba(255,255,255,0.16), rgba(255,255,255,0.10));
      border: 1px solid var(--stroke);
      border-radius: 18px;
      padding: 16px;
      box-shadow: var(--shadow);
      backdrop-filter: blur(14px);
    }
    .modal h2 {
      margin: 4px 0 8px;
      font-size: clamp(18px, 5vw, 24px);
      font-weight: 800;
    }
    .modal p {
      margin: 6px 0 12px;
      opacity: 0.95;
      font-size: clamp(14px, 4.2vw, 16px);
      line-height: 1.3;
    }
    .modal .mini {
      font-size: 12px;
      opacity: 0.8;
    }
    .cta {
      margin-top: 10px;
      display: inline-flex;
      align-items: center;
      gap: 10px;
      background: linear-gradient(180deg, #00f7ff, #19d3ff);
      color: #00243a;
      border: none;
      border-radius: 14px;
      font-weight: 900;
      font-size: clamp(15px, 4.5vw, 17px);
      padding: 12px 16px;
      min-height: 48px;
      box-shadow: 0 10px 20px rgba(0, 247, 255, 0.25), inset 0 1px 0 rgba(255,255,255,0.75);
      cursor: pointer;
      text-decoration: none;
      text-align: center;
    }
    .cta:focus-visible { outline: 3px solid #fff; outline-offset: 2px; }

    /* Results */
    .results {
      position: absolute;
      inset: 0;
      z-index: 6;
      display: none;
      grid-template-rows: auto 1fr auto;
      gap: 10px;
      background: linear-gradient(180deg, rgba(2,7,40,0.25), rgba(2,7,40,0.35));
      padding: 16px;
    }
    .results.active { display: grid; }
    .results-header,
    .results-footer {
      backdrop-filter: blur(10px);
      background: linear-gradient(180deg, rgba(255,255,255,0.16), rgba(255,255,255,0.10));
      border: 1px solid var(--stroke);
      border-radius: 16px;
      padding: 12px;
      box-shadow: var(--shadow);
    }
    .results-body {
      min-height: 0;
      overflow: hidden;
    }
    .results-scroll {
      height: 100%;
      max-height: 90svh;
      @supports not (height: 100svh) { max-height: 90dvh; }
      @supports not (height: 100dvh) { max-height: 90vh; }
      overflow-y: auto; /* Scroll only inside this area in results */
      display: grid;
      gap: 10px;
    }
    .score {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
    }
    .score .big {
      font-size: clamp(20px, 6vw, 28px);
      font-weight: 900;
      letter-spacing: 0.3px;
    }
    .tip {
      font-size: clamp(13px, 3.8vw, 14px);
      opacity: 0.95;
    }
    .item {
      background: linear-gradient(180deg, rgba(255,255,255,0.12), rgba(255,255,255,0.06));
      border: 1px solid var(--stroke);
      border-radius: 14px;
      padding: 10px;
      display: grid;
      gap: 6px;
    }
    .item .q {
      font-weight: 800;
      font-size: 14px;
      line-height: 1.2;
    }
    .ans {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      font-size: 13px;
    }
    .pill {
      display: inline-flex;
      align-items: center;
      padding: 6px 10px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.25);
      background: rgba(255,255,255,0.10);
      gap: 8px;
    }
    .pill.correct { border-color: rgba(102,255,123,0.95); color: #d5ffe0; }
    .pill.wrong   { border-color: rgba(255,77,109,0.95); color: #ffd6de; }
    .explain {
      font-size: 13px;
      opacity: 0.95;
    }
    .results-footer .cta {
      width: 100%;
      position: sticky; /* keep visible over long list */
      bottom: 0;
    }
    .warn {
      margin-top: 6px;
      font-size: 12px;
      opacity: 0.8;
    }

    /* Compact mode for tiny screens (auto via ensureFits) */
    .compact .hud { padding: 6px 8px; min-height: 48px; }
    .compact .logo { width: 84px; }
    .compact .title { font-size: clamp(16px, 4.2vw, 18px); }
    .compact .progress-chip { padding: 6px 10px; }
    .compact .card { padding: 10px; }
    .compact .question { font-size: clamp(16px, 4.8vw, 18px); min-height: 42px; }
    .compact .option-btn { min-height: 48px; padding: 10px 12px; font-size: clamp(13px, 3.8vw, 15px); }
    .compact .app { gap: 8px; }

    /* Utility hidden */
    .hidden { display: none !important; }
  </style>
</head>
<body>
  <div class="scene" id="scene" aria-live="polite">
    <img class="avatar-bg" alt="" src="https://techkampe.github.io/daily-streak/assets/Avatar%203_low.png">
    <div class="bg-noise" aria-hidden="true"></div>

    <div class="app" id="app" style="--ui-scale: 1;">
      <header class="hud" aria-label="Encabezado del reto y progreso">
        <div class="hud-left">
          <img class="logo" src="https://techkampe.github.io/daily-streak/assets/kampe_logo_blanco.png" alt="Kämpe" decoding="async" />
          <div class="title" id="challengeTitle">Corta la Corriente ⚡</div>
        </div>
        <div class="progress-chip" id="progressChip" aria-live="polite">1/5</div>
      </header>

      <main class="card slide-in-right" id="card" role="group" aria-label="Pregunta">
        <div class="question" id="questionText">...</div>
        <div class="options" id="options"></div>
      </main>
    </div>

    <!-- Intro modal (tutorial super breve) -->
    <div class="modal" id="introModal" role="dialog" aria-modal="true" aria-labelledby="introTitle">
      <div class="modal-card">
        <h2 id="introTitle">Corta la Corriente ⚡</h2>
        <p>Responde 5 decisiones rápidas de seguridad eléctrica. Toca una opción para avanzar.</p>
        <p class="mini">Escenario: cambiar un enchufe en vivienda ocupada minimizando interrupciones.</p>
        <button class="cta" id="startBtn" aria-label="Empezar el reto">Empezar</button>
      </div>
    </div>

    <!-- Results screen -->
    <section class="results" id="results" aria-live="polite" aria-label="Resultados del reto">
      <div class="results-header">
        <div class="score">
          <div class="big" id="scoreText">0/5 correctas</div>
          <div class="progress-chip" id="timeChip">Reto diario</div>
        </div>
        <div class="tip" id="generalTip">
          Consejo: avisa al cliente antes del corte y, al reenergizar, retira bloqueos, señala y confirma que nadie esté trabajando cerca.
        </div>
      </div>
      <div class="results-body">
        <div class="results-scroll" id="resultsList" role="list"></div>
      </div>
      <div class="results-footer">
        <a class="cta" id="rewardBtn" href="#" aria-label="Ver mi recompensa">Ver mi recompensa</a>
        <div class="warn" id="initDataWarn" aria-live="polite"></div>
      </div>
    </section>
  </div>

  <script>
    // ----------------------------
    // Data and configuration
    // ----------------------------
    const initData = (() => {
      const usp = new URLSearchParams(location.search);
      return usp.get('initData') || "";
    })();

    const QUESTIONS = [
      {
        q: "Antes de empezar, ¿EPI mínimo?",
        options: [
          { t: "Guantes aislantes + gafas", correct: true },
          { t: "Solo casco", correct: false },
          { t: "Nada: cortaré la luz", correct: false },
          { t: "Solo botas de seguridad", correct: false }
        ],
        explain: "Protege manos y ojos frente a contactos y proyecciones. El resto suma, pero ese es el mínimo."
      },
      {
        q: "¿Qué cortas primero para molestar lo mínimo?",
        options: [
          { t: "Magnetotérmico del circuito del enchufe", correct: true },
          { t: "IGA general", correct: false },
          { t: "Diferencial", correct: false }
        ],
        explain: "Corta solo el circuito afectado. Usa el general solo si no puedes identificar el circuito de forma segura."
      },
      {
        q: "El magnetotérmico no está rotulado. ¿Qué haces?",
        options: [
          { t: "Identificar, rotular temporal y bloquear", correct: true },
          { t: "Bajar interruptores al azar", correct: false },
          { t: "Pedir al cliente que no toque nada", correct: false }
        ],
        explain: "Identifica con una carga de prueba, rotula y aplica bloqueo/etiquetado para evitar reenergizados."
      },
      {
        q: "Mejor forma de confirmar ausencia de tensión",
        options: [
          { t: "Multímetro en V~ + prueba-verifica-prueba", correct: true },
          { t: "Buscapolos", correct: false },
          { t: "La luz está apagada", correct: false }
        ],
        explain: "Usa instrumento homologado y el método PVP: prueba en vivo, verifica el punto, y vuelve a probar en vivo."
      },
      {
        q: "Orden correcto antes de tocar los cables",
        options: [
          { t: "Identificar → desconectar → bloquear → verificar", correct: true },
          { t: "Desconectar → verificar → bloquear", correct: false },
          { t: "Verificar → desconectar → bloquear", correct: false }
        ],
        explain: "Primero ubica el circuito, corta, bloquea/etiqueta y confirma ausencia de tensión."
      }
    ];

    // Ensure labels under 48 chars; summarize if needed
    function clampLabel(text, max = 48) {
      if (!text) return "";
      if (text.length <= max) return text;
      return text.slice(0, max - 1).trimEnd() + "…";
    }

    // ----------------------------
    // State
    // ----------------------------
    let current = 0;
    const answers = []; // {selected, correctIndex, isCorrect}
    let locked = false;

    // ----------------------------
    // DOM references
    // ----------------------------
    const sceneEl = document.getElementById('scene');
    const appEl = document.getElementById('app');
    const cardEl = document.getElementById('card');
    const qTextEl = document.getElementById('questionText');
    const optionsEl = document.getElementById('options');
    const progressChip = document.getElementById('progressChip');

    const introModal = document.getElementById('introModal');
    const startBtn = document.getElementById('startBtn');

    const resultsEl = document.getElementById('results');
    const resultsListEl = document.getElementById('resultsList');
    const rewardBtn = document.getElementById('rewardBtn');
    const scoreText = document.getElementById('scoreText');
    const initDataWarn = document.getElementById('initDataWarn');

    // ----------------------------
    // Renderers
    // ----------------------------
    function renderQuestion(index) {
      const data = QUESTIONS[index];
      // Progress chip
      progressChip.textContent = `${index + 1}/${QUESTIONS.length}`;

      // Update ARIA for the card
      cardEl.setAttribute('aria-label', `Pregunta ${index + 1} de ${QUESTIONS.length}`);

      // Texts
      qTextEl.textContent = data.q;

      // Build options
      optionsEl.innerHTML = "";
      data.options.forEach((opt, i) => {
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.className = 'option-btn';
        btn.setAttribute('aria-label', `Opción ${i + 1}: ${opt.t}`);
        btn.innerHTML = `<span class="label">${clampLabel(opt.t)}</span>`;
        btn.addEventListener('click', () => onPick(i));
        optionsEl.appendChild(btn);
      });

      // Entry animation
      cardEl.classList.remove('slide-out-left');
      void cardEl.offsetWidth; // reflow
      cardEl.classList.add('slide-in-right');

      ensureFits();
    }

    function onPick(idx) {
      if (locked) return;
      locked = true;
      const data = QUESTIONS[current];
      const correctIndex = data.options.findIndex(o => o.correct);
      const isCorrect = idx === correctIndex;

      // Visual feedback
      const buttons = [...optionsEl.querySelectorAll('.option-btn')];
      buttons[idx].classList.add(isCorrect ? 'correct' : 'wrong');

      // Save answer
      answers[current] = { selected: idx, correctIndex, isCorrect };

      // Auto-advance with small delay + animation
      setTimeout(() => {
        cardEl.classList.remove('slide-in-right');
        cardEl.classList.add('slide-out-left');
        setTimeout(() => {
          current++;
          if (current < QUESTIONS.length) {
            renderQuestion(current);
            locked = false;
          } else {
            showResults();
          }
        }, 210);
      }, 260);
    }

    // ----------------------------
    // Results
    // ----------------------------
    function showResults() {
      // Compute score
      const corrects = answers.filter(a => a?.isCorrect).length;
      scoreText.textContent = `${corrects}/${QUESTIONS.length} correctas`;

      // Build list
      resultsListEl.innerHTML = "";
      QUESTIONS.forEach((q, i) => {
        const item = document.createElement('div');
        item.className = 'item';
        item.setAttribute('role', 'listitem');

        const qEl = document.createElement('div');
        qEl.className = 'q';
        qEl.textContent = `${i + 1}. ${q.q}`;

        const ansWrap = document.createElement('div');
        ansWrap.className = 'ans';

        const user = document.createElement('span');
        user.className = 'pill ' + (answers[i]?.isCorrect ? 'correct' : 'wrong');
        user.textContent = `Tu respuesta: ${q.options[answers[i]?.selected]?.t ?? '—'}`;

        const corr = document.createElement('span');
        corr.className = 'pill correct';
        corr.textContent = `Correcta: ${q.options[answers[i]?.correctIndex]?.t}`;

        const expl = document.createElement('div');
        expl.className = 'explain';
        expl.textContent = q.explain;

        ansWrap.appendChild(user);
        ansWrap.appendChild(corr);
        item.appendChild(qEl);
        item.appendChild(ansWrap);
        item.appendChild(expl);
        resultsListEl.appendChild(item);
      });

      // Reward link
      const base = "https://kampe-game-phaser.onrender.com/daily_streak";
      rewardBtn.href = `${base}?initData=${encodeURIComponent(initData)}`;
      if (!initData) {
        initDataWarn.textContent = "Aviso: initData no detectado. Abriremos tu recompensa igualmente.";
      } else {
        initDataWarn.textContent = "";
      }

      // Activate results view, allow scrolling now (only here)
      resultsEl.classList.add('active');
      document.body.style.overflowY = 'auto';
      // The interactive area should allow gestures now
      sceneEl.style.touchAction = 'auto';

      // Keep gameplay behind but hidden from a11y focus
      introModal.classList.add('hidden');

      // Make sure results layout is fine
      ensureFits(); // still keeps top header, but now scrolling is allowed in results body
    }

    // ----------------------------
    // Fitting / Scaling Guardrails
    // ----------------------------
    function assertNoOverflow() {
      const ok = sceneEl.scrollHeight <= sceneEl.clientHeight;
      // Optional: debug
      // console.debug('assertNoOverflow', { ok, scrollHeight: sceneEl.scrollHeight, clientHeight: sceneEl.clientHeight });
      return ok;
    }

    function applyCompactMode() {
      if (!document.body.classList.contains('compact')) {
        document.body.classList.add('compact');
      }
    }

    function fitBoardToViewport() {
      // Adjust variables slightly to free space
      const root = document.documentElement;
      root.style.setProperty('--gap', '10px');
      root.style.setProperty('--btnH', '52px');
    }

    function autoscaleUI(minScale = 0.88) {
      // Compute scale factor based on content vs viewport height
      // We'll scale the app container
      const viewportH = sceneEl.clientHeight;
      // Temporarily remove transform to measure
      appEl.style.transform = 'scale(1)';
      const contentH = sceneEl.scrollHeight;
      let scale = Math.min(1, viewportH / (contentH + 1)); // +1 to avoid 1:1 case rounding
      if (scale < minScale) scale = minScale;
      document.documentElement.style.setProperty('--ui-scale', scale.toFixed(3));
      appEl.style.transform = `scale(var(--ui-scale))`;
    }

    function ensureFits() {
      // Reset states before checks
      document.body.classList.remove('compact');
      document.documentElement.style.removeProperty('--gap');
      document.documentElement.style.removeProperty('--btnH');
      document.documentElement.style.setProperty('--ui-scale', 1);
      appEl.style.transform = 'scale(1)';

      // Only run tight fitting during gameplay (results can scroll internally)
      const inResults = resultsEl.classList.contains('active');

      // Step 1: check
      if (assertNoOverflow() || inResults) return;

      // Step 2: compact mode
      applyCompactMode();
      if (assertNoOverflow()) return;

      // Step 3: tweak layout vars
      fitBoardToViewport();
      if (assertNoOverflow()) return;

      // Step 4: autoscale
      autoscaleUI(0.88);
    }

    // ----------------------------
    // Init and events
    // ----------------------------
    function startGame() {
      introModal.classList.add('hidden');
      // Keep scroll locked during gameplay
      document.body.style.overflow = 'hidden';
      sceneEl.style.touchAction = 'none';

      current = 0;
      answers.length = 0;
      renderQuestion(current);
    }

    startBtn.addEventListener('click', startGame);

    // Render first question data under the intro blur (so ensureFits can plan)
    renderQuestion(0);

    // Resize handlers
    let resizeTimer;
    function onResize() {
      clearTimeout(resizeTimer);
      resizeTimer = setTimeout(() => ensureFits(), 50);
    }
    window.addEventListener('resize', onResize);
    window.addEventListener('orientationchange', () => {
      setTimeout(() => ensureFits(), 200);
    });

    // Run after first paint
    window.addEventListener('load', () => {
      ensureFits();
    });

    // Keyboard accessibility: allow Enter/Space to pick focused option
    optionsEl.addEventListener('keydown', (e) => {
      if ((e.key === 'Enter' || e.key === ' ') && e.target.classList.contains('option-btn')) {
        e.preventDefault();
        e.target.click();
      }
    });

    // Safety: clamp potentially too-long labels (runtime)
    function enforceMaxLabelLength() {
      document.querySelectorAll('.option-btn .label').forEach(el => {
        const txt = el.textContent || "";
        if (txt.length > 48) el.textContent = clampLabel(txt, 48);
      });
      if ((qTextEl.textContent || "").length > 80) {
        qTextEl.textContent = clampLabel(qTextEl.textContent, 80);
      }
    }
    const obs = new MutationObserver(() => enforceMaxLabelLength());
    obs.observe(optionsEl, { childList: true, subtree: true });
  </script>
</body>
</html>